/* 
 * Swagger Petstore
 *
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

//package petstore

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"

// model import
local _user_api = require ".user_api"

local petstore= {}
local _mt = {
  __name = "";
  __index = petstore;
}

local function new_user_api(host, basePath, schemes)
  local schemes_map = {}
  for _,v in ipairs(schemes) do
    schemes_map[v] = v
  end
  local default_scheme = schemes_map.https or schemes_map.http
  // TODO: default basePath to http://petstore.swagger.io/v2
  return setmetatable({
    host = host;
    basePath = basePath;
    schemes = schemes_map;
    default_scheme = default_scheme;
  }, _mt)
end

function user_api:create_user(body)
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s//user", self.basePath, petId);
    })

    // set HTTP verb
	req.headers:upsert(":method", "Post")

    // TODO: create a function to select proper accept
    local var_accept = {  }
    req.headers:upsert("accept", )

    // TODO: create a function to select proper content-type
    local var_accept = { "application/xml", "application/json" }
    req.headers:upsert("content-type", "application/xml")





    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return _user_api.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

function user_api:create_users_with_array_input(body)
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s//user/createWithArray", self.basePath, petId);
    })

    // set HTTP verb
	req.headers:upsert(":method", "Post")

    // TODO: create a function to select proper accept
    local var_accept = {  }
    req.headers:upsert("accept", )

    // TODO: create a function to select proper content-type
    local var_accept = { "application/xml", "application/json" }
    req.headers:upsert("content-type", "application/xml")





    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return _user_api.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

function user_api:create_users_with_list_input(body)
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s//user/createWithList", self.basePath, petId);
    })

    // set HTTP verb
	req.headers:upsert(":method", "Post")

    // TODO: create a function to select proper accept
    local var_accept = {  }
    req.headers:upsert("accept", )

    // TODO: create a function to select proper content-type
    local var_accept = { "application/xml", "application/json" }
    req.headers:upsert("content-type", "application/xml")





    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return _user_api.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

function user_api:delete_user(username)
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s//user/{username}", self.basePath, petId);
    })

    // set HTTP verb
	req.headers:upsert(":method", "Delete")

    // TODO: create a function to select proper accept
    local var_accept = {  }
    req.headers:upsert("accept", )

    // TODO: create a function to select proper content-type
    local var_accept = { "application/xml", "application/json" }
    req.headers:upsert("content-type", "application/xml")





    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return _user_api.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

function user_api:get_user_by_name(username)
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s//user/{username}", self.basePath, petId);
    })

    // set HTTP verb
	req.headers:upsert(":method", "Get")

    // TODO: create a function to select proper accept
    local var_accept = {  }
    req.headers:upsert("accept", )

    // TODO: create a function to select proper content-type
    local var_accept = { "application/xml", "application/json" }
    req.headers:upsert("content-type", "application/xml")





    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return _user_api.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

function user_api:login_user(username, password)
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s//user/login", self.basePath, petId);
    })

    // set HTTP verb
	req.headers:upsert(":method", "Get")

    // TODO: create a function to select proper accept
    local var_accept = {  }
    req.headers:upsert("accept", )

    // TODO: create a function to select proper content-type
    local var_accept = { "application/xml", "application/json" }
    req.headers:upsert("content-type", "application/xml")



    // TODO query params username (username)
    // TODO query params password (password)


    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return _user_api.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

function user_api:logout_user()
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s//user/logout", self.basePath, petId);
    })

    // set HTTP verb
	req.headers:upsert(":method", "Get")

    // TODO: create a function to select proper accept
    local var_accept = {  }
    req.headers:upsert("accept", )

    // TODO: create a function to select proper content-type
    local var_accept = { "application/xml", "application/json" }
    req.headers:upsert("content-type", "application/xml")





    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return _user_api.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

function user_api:update_user(username, body)
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s//user/{username}", self.basePath, petId);
    })

    // set HTTP verb
	req.headers:upsert(":method", "Put")

    // TODO: create a function to select proper accept
    local var_accept = {  }
    req.headers:upsert("accept", )

    // TODO: create a function to select proper content-type
    local var_accept = { "application/xml", "application/json" }
    req.headers:upsert("content-type", "application/xml")





    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return _user_api.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

