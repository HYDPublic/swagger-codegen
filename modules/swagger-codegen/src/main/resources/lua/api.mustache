{{>partial_header}}
//package {{packageName}}

{{#operations}}
local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"

// model import
local {{{packageName}}}_{{classname}} = require "{{{packageName}}}.{{classname}}"

local {{{packageName}}}= {}
local {{{packageName}}}_mt = {
  __name = "{{{packageNameHyphen}}}";
  __index = {{{packageName}}};
}

local function new_{{classname}}(host, basePath, schemes)
  local schemes_map = {}
  for _,v in ipairs(schemes) do
    schemes_map[v] = v
  end
  local default_scheme = schemes_map.https or schemes_map.http
  // TODO: default basePath to {{{basePath}}}
  return setmetatable({
    host = host;
    basePath = basePath or "{{{basePath}}}";
    schemes = schemes_map;
    default_scheme = default_scheme;
  }, {{{packageName}}}_mt)
end

{{#operation}}
function {{classname}}:{{operationId}}({{#allParams}}{{#required}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}})
    local req = http_request.new_from_uri({
        scheme = self.default_scheme;
        host = self.host;
        path = string.format("%s{{{vendorExtensions.x-codegen-path}}}", self.basePath{{#pathParams}} ,{{paramName}}{{/pathParams}});
    })

    // set HTTP verb
    req.headers:upsert(":method", "{{httpMethod}}")

    // TODO: create a function to select proper accept
    local var_accept = { {{#consumes}}"{{{mediaType}}}"{{#hasMore}}, {{/hasMore}}{{/consumes}} }
    req.headers:upsert("accept", {{#consumes}}{{#-first}}"{{{mediaType}}}"{{/-first}}{{/consumes}})

    // TODO: create a function to select proper content-type
    local var_accept = { {{#produces}}"{{{mediaType}}}"{{#hasMore}}, {{/hasMore}}{{/produces}} }
    req.headers:upsert("content-type", {{#produces}}{{#-first}}"{{{mediaType}}}"{{/-first}}{{/produces}})

    {{#headerParams}}
    req.headers:upsert("{{baseName}}", {{paramName}})
    {{/headerParams}}

    {{#formParams}}
    {{#-first}}
    req:set_body(http_util.dict_to_query({
    {{/-first}}
        ["{{baseName}}"] = {{paramName}};
    {{#-last}}
    }))
    {{/-last}}
    {{/formParams}}

    {{#queryParams}}
    // TODO query params {{paramName}} ({{baseName}})
    {{/queryParams}}

    {{#authMethods}}
    {{#isApiKey}}
    //TODO '{{keyParamName}}'
    {{#isKeyInHeader}}
    // api key in headers '{{keyParamName}}'
    {{/isKeyInHeader}}
    {{#isKeyInQuery}}
    /// api key in query '{{keyParamName}}'
    {{/isKeyInQuery}}
    {{/isApiKey}}
    {{#isBasic}}
    // TODO HTTP basic auth
    {{/isBasic}}
    {{#isOAuth}}
    // TODO oauth
    {{/isOAuth}}
    {{/authMethods}}

    // make the HTTP call
    local headers, stream, errno = req:go()
    if not headers then
        return nil, stream, errno
    end
    local http_status = headers:get(":status")
    if http_status == "200" then
        local body, err, errno2 = stream:get_body_as_string()
        if not body then
            return nil, err, errno2
        end
        stream:shutdown()
        local result, _, err3 = dkjson.decode(body)
        if result == nil then
            return nil, err3
        end
        return {{{packageName}}}_{{classname}}.cast(result)
    else
        stream:shutdown()
        return nil, "Unexpected response status code"
    end
end

{{/operation}}
{{/operations}}
